Cada una de las carpetas contiene archivos de C que usé para correr el
modelo en alguna fase del trabajo. Acá voy a ir anotando qué es lo que
se suponía que hiciera el código en esa fase.

.) CI_variables:
----------------

El objetivo de esta etapa es estudiar cómo cambia el punto fijo al cual tiende el sistema para
una dada configuración de parámetros en función de las condiciones iniciales de la red. Para
eso lo que hago es modificar los valores iniciales del sistema de forma tal que se distribuyan
a lo largo de la región [0;Kappa]. De estas simulaciones sólamente me guardo datos de los
intereses finales del sistema, es decir que sólo me guardo los archivos de Opiniones. Los de
Testigos no me resultan necesarios porque no planeo estudiar el comportamiento del sistema
durante su evolución. Con los intereses finales de todos los agentes de una simulación hago
un promedio y considero ese valor promedio como el punto fijo al cuál tiende el sistema. Esto
lo hago bajo la suposición de que todos los agentes en todos los tópicos tienden al mismo
valor de interés. Esos valores de "puntos fijos" los voy a usar para armar gráficos 3D que me
permitan observar las curvas de transición del sistema de un único punto fijo a tres puntos
fijos, una transcrítica en resumen. Ese es el plan por lo menos.
 De la misma forma, si tengo dudas de si los agentes realmente todos convergen al mismo punto fijo,
podría simplemente armar gráficos de intereses en el espacio de fases. Mi idea es que deberían
caer todos los puntos en lugares suficientemente cercanos.
 Para los datos de esto cambié los nombres de los archivos, ahora llevan el nombre de tres parámetros
en el barrido: Cosdelta, Kappa y Epsilon. La idea es que justamente quiero barrer todo junto
en una sola tirada de datos. El Cosdelta varía entre [0;1], el Kappa entre [0,5;2] y el Epsilon
entre [1,5;3,5]. El alfa sigue siendo 4.

.) Exploración_logística:
-------------------------

Hice un barrido en Kappa y Alfa para estudiar el comportamiento del sistema. El barrido está
hecho para Kappa entre [1,3] (creo) y Alfa entre [5,8]. El sistema tenía N=1000, 1 tópico y
epsilon=3 (creo). La idea era ver cómo el sistema se comportaba en el espacio de fases, sabiendo
que estaba barriendo en la región de transición. Creo que tengo un barrido más fino para valores
de K menores a 2. Por lo que vi hay algunos gráficos de opinión versus tiempo y uno de Promedio
de Opiniones en el espacio de fases.
 Esto es lo que puedo recordar de lo que tengo anotado y de lo que tengo en la carpeta
de Programas. Lo que tengo en Oporto es un código distinto al que tengo en la pc, que parece
estar dispuesto para recibir tres variables como input, mientras que el de la pc sólo recibe 2.
Además, sospecho que ese código se usó también para la etapa de Complemento_Poster, la cuál fue
una etapa breve que no tenía un fin de una investigación o un concepto nuevo, sino que simplemente
era para separar las cosas que necesitaba particularmente hacer para mi poster.
 Reemplacé lo que había en la pc de la facultad con lo que había en Oporto.


.)Homofilia_estatica:
---------------------

Pablo se conoció con una gente de España y descubrió que estaban trabajando en un modelo de
Baumann unidimensional en el cuál integraban la homofilia entre agentes como un peso en los
enlaces. Eso les permitía observar estados ideológicos, estados de consenso y de radicalización.
Lo que nosotros estamos haciendo entonces es tomar este modelo con estos pesos y simular para
el caso 1D cosa de ver que nos de lo mismo que a ellos y después hicimos simulaciones 2D que
es lo que ellos no tenían.
 Este modelo tiene 1000 agentes, toma alfa=1, agrega el parámetro beta para graduar la homofilia
y barre en Beta y Cos(delta).
 Para el caso 1D armé una carpeta, 1D, en la que guardo los datos del modelo. Lo que hice fue
simular unos puntos particulares para ver que observo al igual que en el paper que nos pasaron
que el sistema converge a estados de polarización, radicalización y consenso neutro.
 Para el caso 2D tuve que implementar una nueva función que calcule las distancias de los vectores
en el espacio no ortogonal. Eso era necesario para poder calcular los pesos homofílicos entre agentes.
Actualmente tengo una sola forma de calcular esa distancia, pero hablando con la gente de España en
realidad me propusieron otras ideas de qué hacer, así que voy a tener que considerar cómo agregar
esas modificaciones y guardar esos datos en carpetas nuevas. Creo que lo mejor va a ser separar
en distintas etapas.

.)Tangente_diferenciada:
---------------------

Al calcular el efecto de las opiniones de los vecinos, en esta etapa voy a considerar sólo la opinión
del vecino en el tópico considerado. Por tanto, voy a descartar el valor de Cos(delta) en la tanh.
Pensé que iba a ser poner una matriz de superposición que sea la identidad, pero me doy cuenta que no
es tan simple, porque si hago eso, me jodo el cálculo de los pesos w_ij. Creo que tengo que actuar
directamente sobre la función dinámica.
 Este modelo lo apliqué a redes con 1000 agentes. En principio hice simplemente unas simulaciones
rápidas en Oporto, me encargué de armar datos para Beta = 0.1, 1 y 1.5, combinado con Cos(delta) = 0,
0.5 y 1. El kappa es 3, como siempre creo.

.)Distancias_independientes:
---------------------

La otra métrica que propusieron es modificar los pesos de forma tal que al calcularlos, considere las
distancias de los agentes en el tópico en cuestión. En este caso, no hay problema al definir el módulo
del vector porque es simplemente el módulo entre dos números escalares, no importa para nada el
tema del espacio no ortogonal.

.)Medidas_polarizacion:
-----------------------

El código que utilicé acá es muy similar al de Homofilia_estática. Es una evolución del modelo con
el peso homofílico en los enlaces, redes estáticas, grado medio de las redes igual a 10, tomando
Beta, Kappa, Cos(delta) y N como input, los datos que genero a la salida son los mismo que siempre,
con un archivo de Opiniones y otro de Testigos. Creo que al final el de Testigos lo cancelé en
esta tanda.
 La diferencia importante es que a partir de acá empecé a usar un dt=0.1, en vez del de 0.01 que estaba
usando antes.
